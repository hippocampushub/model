{"version":3,"file":"static/chunks/9672-aca3da68b73ed94b.js","mappings":"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","sources":["webpack://_N_E/./node_modules/lodash/isNil.js","webpack://_N_E/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs","webpack://_N_E/./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs","webpack://_N_E/./node_modules/@sentry/utils/build/esm/version.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/worldwide.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/carrier.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/is.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/misc.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/propagationContext.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/time.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/debug-build.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/logger.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/session.js","webpack://_N_E/./node_modules/@sentry/utils/build/esm/object.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/utils/spanOnScope.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/scope.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/defaultScopes.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/asyncContext/index.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/currentScopes.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/utils/prepareEvent.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/exports.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","// utility for whatwg streams\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nexport function isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction assertNonNull(value) {\n    if (value == null) {\n        throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n}\nexport function asyncIterableFromStream(stream) {\n    return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3 /*break*/, 8];\n                    return [4 /*yield*/, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [3 /*break*/, 5];\n                    return [4 /*yield*/, __await(void 0)];\n                case 4: return [2 /*return*/, _b.sent()];\n                case 5:\n                    assertNonNull(value);\n                    return [4 /*yield*/, __await(value)];\n                case 6: return [4 /*yield*/, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 2];\n                case 8: return [3 /*break*/, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7 /*endfinally*/];\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Decoder } from \"./Decoder.mjs\";\nimport { ensureAsyncIterable } from \"./utils/stream.mjs\";\nimport { defaultDecodeOptions } from \"./decode.mjs\";\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeAsync(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    return __awaiter(this, void 0, void 0, function () {\n        var stream, decoder;\n        return __generator(this, function (_a) {\n            stream = ensureAsyncIterable(streamLike);\n            decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [2 /*return*/, decoder.decodeAsync(stream)];\n        });\n    });\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeArrayStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var stream = ensureAsyncIterable(streamLike);\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var stream = ensureAsyncIterable(streamLike);\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nexport function decodeStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    return decodeMultiStream(streamLike, options);\n}\n//# sourceMappingURL=decodeAsync.mjs.map","const SDK_VERSION = '8.36.0';\n\nexport { SDK_VERSION };\n//# sourceMappingURL=version.js.map\n","import { SDK_VERSION } from './version.js';\n\n/** Get's the global object for the current JavaScript runtime */\nconst GLOBAL_OBJ = globalThis ;\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(name, creator, obj) {\n  const gbl = (obj || GLOBAL_OBJ) ;\n  const __SENTRY__ = (gbl.__SENTRY__ = gbl.__SENTRY__ || {});\n  const versionedCarrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n  return versionedCarrier[name] || (versionedCarrier[name] = creator());\n}\n\nexport { GLOBAL_OBJ, getGlobalSingleton };\n//# sourceMappingURL=worldwide.js.map\n","import { GLOBAL_OBJ, SDK_VERSION } from '@sentry/utils';\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(GLOBAL_OBJ);\n  return GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nfunction getSentryCarrier(carrier) {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n}\n\nexport { getMainCarrier, getSentryCarrier };\n//# sourceMappingURL=carrier.js.map\n","// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isParameterizedString(wat) {\n  return (\n    typeof wat === 'object' &&\n    wat !== null &&\n    '__sentry_template_string__' in wat &&\n    '__sentry_template_values__' in wat\n  );\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\n/**\n * Checks whether given value's type is a Vue ViewModel.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isVueViewModel(wat) {\n  // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n  return !!(typeof wat === 'object' && wat !== null && ((wat ).__isVue || (wat )._isVue));\n}\n\nexport { isDOMError, isDOMException, isElement, isError, isErrorEvent, isEvent, isInstanceOf, isParameterizedString, isPlainObject, isPrimitive, isRegExp, isString, isSyntheticEvent, isThenable, isVueViewModel };\n//# sourceMappingURL=is.js.map\n","import { addNonEnumerableProperty } from './object.js';\nimport { snipLine } from './string.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  const gbl = GLOBAL_OBJ ;\n  const crypto = gbl.crypto || gbl.msCrypto;\n\n  let getRandomByte = () => Math.random() * 16;\n  try {\n    if (crypto && crypto.randomUUID) {\n      return crypto.randomUUID().replace(/-/g, '');\n    }\n    if (crypto && crypto.getRandomValues) {\n      getRandomByte = () => {\n        // crypto.getRandomValues might return undefined instead of the typed array\n        // in old Chromium versions (e.g. 23.0.1235.0 (151422))\n        // However, `typedArray` is still filled in-place.\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#typedarray\n        const typedArray = new Uint8Array(1);\n        crypto.getRandomValues(typedArray);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return typedArray[0];\n      };\n    }\n  } catch (_) {\n    // some runtimes can crash invoking crypto\n    // https://github.com/getsentry/sentry-javascript/issues/8935\n  }\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n    // eslint-disable-next-line no-bitwise\n    ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\nfunction _parseInt(input) {\n  return parseInt(input || '', 10);\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = _parseInt(match[1]);\n  const minor = _parseInt(match[2]);\n  const patch = _parseInt(match[3]);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping\n  if (frame.lineno === undefined) {\n    return;\n  }\n\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  // We guard here to ensure this is not larger than the existing number of lines\n  const lineIndex = Math.min(maxLines - 1, sourceLine);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  frame.context_line = snipLine(lines[lineIndex], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (exception && (exception ).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, arrayify, checkOrSetAlreadyCaught, getEventDescription, parseSemver, uuid4 };\n//# sourceMappingURL=misc.js.map\n","import { uuid4 } from './misc.js';\n\n/**\n * Returns a new minimal propagation context\n */\nfunction generatePropagationContext() {\n  return {\n    traceId: uuid4(),\n    spanId: uuid4().substring(16),\n  };\n}\n\nexport { generatePropagationContext };\n//# sourceMappingURL=propagationContext.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n *\n * TODO(v8): Return type should be rounded.\n */\nfunction dateTimestampInSeconds() {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const { performance } = GLOBAL_OBJ ;\n  if (!performance || !performance.now) {\n    return dateTimestampInSeconds;\n  }\n\n  // Some browser and environments don't have a timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  const approxStartingTimeOrigin = Date.now() - performance.now();\n  const timeOrigin = performance.timeOrigin == undefined ? approxStartingTimeOrigin : performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nconst timestampInSeconds = createUnixTimestampInSecondsFunc();\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nlet _browserPerformanceTimeOriginMode;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nconst browserPerformanceTimeOrigin = (() => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = GLOBAL_OBJ ;\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing && performance.timing.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n\nexport { _browserPerformanceTimeOriginMode, browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds };\n//# sourceMappingURL=time.js.map\n","/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexport { DEBUG_BUILD };\n//# sourceMappingURL=debug-build.js.map\n","import { DEBUG_BUILD } from './debug-build.js';\nimport { getGlobalSingleton, GLOBAL_OBJ } from './worldwide.js';\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nconst CONSOLE_LEVELS = [\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'log',\n  'assert',\n  'trace',\n] ;\n\n/** This may be mutated by the console instrumentation. */\nconst originalConsoleMethods\n\n = {};\n\n/** JSDoc */\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  if (!('console' in GLOBAL_OBJ)) {\n    return callback();\n  }\n\n  const console = GLOBAL_OBJ.console ;\n  const wrappedFuncs = {};\n\n  const wrappedLevels = Object.keys(originalConsoleMethods) ;\n\n  // Restore all wrapped console methods\n  wrappedLevels.forEach(level => {\n    const originalConsoleMethod = originalConsoleMethods[level] ;\n    wrappedFuncs[level] = console[level] ;\n    console[level] = originalConsoleMethod;\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    wrappedLevels.forEach(level => {\n      console[level] = wrappedFuncs[level] ;\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  const logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n    isEnabled: () => enabled,\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n * The logger is a singleton on the carrier, to ensure that a consistent logger is used throughout the SDK.\n */\nconst logger = getGlobalSingleton('logger', makeLogger);\n\nexport { CONSOLE_LEVELS, consoleSandbox, logger, originalConsoleMethods };\n//# sourceMappingURL=logger.js.map\n","import { timestampInSeconds, uuid4, dropUndefinedKeys } from '@sentry/utils';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = timestampInSeconds();\n\n  const session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. — Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return dropUndefinedKeys({\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  });\n}\n\nexport { closeSession, makeSession, updateSession };\n//# sourceMappingURL=session.js.map\n","import { htmlTreeAsString } from './browser.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { isError, isEvent, isInstanceOf, isElement, isPlainObject, isPrimitive } from './is.js';\nimport { logger } from './logger.js';\nimport { truncate } from './string.js';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] ;\n  const wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    markFunctionWrapped(wrapped, original);\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  try {\n    Object.defineProperty(obj, name, {\n      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n      value: value,\n      writable: true,\n      configurable: true,\n    });\n  } catch (o_O) {\n    DEBUG_BUILD && logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n  }\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  try {\n    const proto = original.prototype || {};\n    wrapped.prototype = original.prototype = proto;\n    addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n  } catch (o_O) {} // eslint-disable-line no-empty\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nfunction urlEncode(object) {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(\n  value,\n)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    const newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  const firstKey = keys[0];\n\n  if (!firstKey) {\n    return '[object has no keys]';\n  }\n\n  if (firstKey.length >= maxLength) {\n    return truncate(firstKey, maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  const memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  if (isPojo(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n    const memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    const returnValue = {};\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    for (const key of Object.getOwnPropertyNames(inputValue)) {\n      if (typeof inputValue[key] !== 'undefined') {\n        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n      }\n    }\n\n    return returnValue ;\n  }\n\n  if (Array.isArray(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n    const memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    const returnValue = [];\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach((item) => {\n      returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  return inputValue;\n}\n\nfunction isPojo(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  try {\n    const name = (Object.getPrototypeOf(input) ).constructor.name;\n    return !name || name === 'Object';\n  } catch (e) {\n    return true;\n  }\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\nexport { addNonEnumerableProperty, convertToPlainObject, dropUndefinedKeys, extractExceptionKeysForMessage, fill, getOriginalFunction, markFunctionWrapped, objectify, urlEncode };\n//# sourceMappingURL=object.js.map\n","import { addNonEnumerableProperty } from '@sentry/utils';\n\nconst SCOPE_SPAN_FIELD = '_sentrySpan';\n\n/**\n * Set the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _setSpanForScope(scope, span) {\n  if (span) {\n    addNonEnumerableProperty(scope , SCOPE_SPAN_FIELD, span);\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete (scope )[SCOPE_SPAN_FIELD];\n  }\n}\n\n/**\n * Get the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _getSpanForScope(scope) {\n  return scope[SCOPE_SPAN_FIELD];\n}\n\nexport { _getSpanForScope, _setSpanForScope };\n//# sourceMappingURL=spanOnScope.js.map\n","import { generatePropagationContext, isPlainObject, dateTimestampInSeconds, uuid4, logger } from '@sentry/utils';\nimport { updateSession } from './session.js';\nimport { _setSpanForScope, _getSpanForScope } from './utils/spanOnScope.js';\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information.\n */\nclass ScopeClass  {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** Request Mode Session Status */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = generatePropagationContext();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clone() {\n    const newScope = new ScopeClass();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._requestSession = this._requestSession;\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    _setSpanForScope(newScope, _getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getRequestSession() {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setRequestSession(requestSession) {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const [scopeInstance, requestSession] =\n      scopeToMerge instanceof Scope\n        ? [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()]\n        : isPlainObject(scopeToMerge)\n          ? [captureContext , (captureContext ).requestSession]\n          : [];\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    if (requestSession) {\n      this._requestSession = requestSession;\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._session = undefined;\n    _setSpanForScope(this, undefined);\n    this._attachments = [];\n    this._propagationContext = generatePropagationContext();\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n    };\n\n    const breadcrumbs = this._breadcrumbs;\n    breadcrumbs.push(mergedBreadcrumb);\n    this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /** @inheritDoc */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: _getSpanForScope(this),\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureException(exception, hint) {\n    const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint) {\n    const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\n// NOTE: By exporting this here as const & type, instead of doing `export class`,\n// We can get the correct class when importing from `@sentry/core`, but the original type (from `@sentry/types`)\n// This is helpful for interop, e.g. when doing `import type { Scope } from '@sentry/node';` (which re-exports this)\n\n/**\n * Holds additional event information.\n */\nconst Scope = ScopeClass;\n\n/**\n * Holds additional event information.\n */\n\nexport { Scope };\n//# sourceMappingURL=scope.js.map\n","import { getGlobalSingleton } from '@sentry/utils';\nimport { Scope } from './scope.js';\n\n/** Get the default current scope. */\nfunction getDefaultCurrentScope() {\n  return getGlobalSingleton('defaultCurrentScope', () => new Scope());\n}\n\n/** Get the default isolation scope. */\nfunction getDefaultIsolationScope() {\n  return getGlobalSingleton('defaultIsolationScope', () => new Scope());\n}\n\nexport { getDefaultCurrentScope, getDefaultIsolationScope };\n//# sourceMappingURL=defaultScopes.js.map\n","import { isThenable } from '@sentry/utils';\nimport { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes.js';\nimport { Scope } from '../scope.js';\nimport { getMainCarrier, getSentryCarrier } from '../carrier.js';\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack() ;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\nexport { AsyncContextStack, getStackAsyncContextStrategy };\n//# sourceMappingURL=stackStrategy.js.map\n","import { getMainCarrier, getSentryCarrier } from '../carrier.js';\nimport { getStackAsyncContextStrategy } from './stackStrategy.js';\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nfunction setAsyncContextStrategy(strategy) {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nfunction getAsyncContextStrategy(carrier) {\n  const sentry = getSentryCarrier(carrier);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return getStackAsyncContextStrategy();\n}\n\nexport { getAsyncContextStrategy, setAsyncContextStrategy };\n//# sourceMappingURL=index.js.map\n","import { getGlobalSingleton } from '@sentry/utils';\nimport { getAsyncContextStrategy } from './asyncContext/index.js';\nimport { getMainCarrier } from './carrier.js';\nimport { Scope } from './scope.js';\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current exection context.\n */\nfunction getIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(\n  ...rest\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(\n  ...rest\n\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\nexport { getClient, getCurrentScope, getGlobalScope, getIsolationScope, withIsolationScope, withScope };\n//# sourceMappingURL=currentScopes.js.map\n","import { uuid4, dateTimestampInSeconds, addExceptionMechanism, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalScope } from '../currentScopes.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\nconst debugIdStackParserCache = new WeakMap();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.entries(debugIdMap).reduce(\n    (acc, [debugIdStackTrace, debugIdValue]) => {\n      let parsedStack;\n      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n      if (cachedParsedStack) {\n        parsedStack = cachedParsedStack;\n      } else {\n        parsedStack = stackParser(debugIdStackTrace);\n        debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n      }\n\n      for (let i = parsedStack.length - 1; i >= 0; i--) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const stackFrame = parsedStack[i];\n        if (stackFrame.filename) {\n          acc[stackFrame.filename] = debugIdValue;\n          break;\n        }\n      }\n      return acc;\n    },\n    {},\n  );\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(\n  scope,\n  captureContext,\n) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(\n  hint,\n) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'requestSession',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n","import { logger, uuid4, timestampInSeconds, isThenable, GLOBAL_OBJ } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from './constants.js';\nimport { getCurrentScope, getIsolationScope, getClient, withIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { makeSession, updateSession, closeSession } from './session.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  exception,\n  hint,\n) {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContext(name, context) {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status) {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  return withIsolationScope(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      Promise.resolve(maybePromiseResult).then(\n        () => {\n          finishCheckIn('ok');\n        },\n        () => {\n          finishCheckIn('error');\n        },\n      );\n    } else {\n      finishCheckIn('ok');\n    }\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = getClient();\n  return !!client && client.getOptions().enabled !== false && !!client.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const client = getClient();\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const { release, environment = DEFAULT_ENVIRONMENT } = (client && client.getOptions()) || {};\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    release,\n    environment,\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession && currentSession.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n\n  // TODO (v8): Remove this and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  currentScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const client = getClient();\n  // TODO (v8): Remove currentScope and only use the isolation scope(?).\n  // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\nexport { addEventProcessor, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, endSession, flush, isEnabled, isInitialized, lastEventId, setContext, setExtra, setExtras, setTag, setTags, setUser, startSession, withMonitor };\n//# sourceMappingURL=exports.js.map\n"],"names":["module","exports","value","__generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","next","verb","Symbol","iterator","n","v","step","op","call","done","pop","length","push","e","__await","__asyncGenerator","_arguments","generator","asyncIterator","i","apply","q","Promise","a","b","resume","r","resolve","then","fulfill","reject","settle","shift","decodeAsync_generator","decodeAsync","streamLike","options","P","decode","dZ","stream","_a","object","asyncIterableFromStream","arguments","reader","_b","getReader","read","assertNonNull","releaseLock","decoder","dist_es5_esm_Decoder","h","extensionCodec","context","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","fulfilled","rejected","result","adopt","SDK_VERSION","worldwide_GLOBAL_OBJ","globalThis","worldwide_getGlobalSingleton","name","creator","obj","gbl","__SENTRY__","versionedCarrier","carrier_getSentryCarrier","carrier","version","objectToString","Object","prototype","toString","misc_uuid4","crypto","msCrypto","getRandomByte","Math","random","randomUUID","replace","getRandomValues","typedArray","Uint8Array","c","generatePropagationContext","traceId","spanId","substring","time_dateTimestampInSeconds","Date","now","time_timestampInSeconds","createUnixTimestampInSecondsFunc","performance","approxStartingTimeOrigin","timeOrigin","undefined","performanceNow","dateNow","timeOriginDelta","abs","navigationStart","timing","navigationStartDelta","hasNavigationStart","timeOriginIsReliable","debug_build_DEBUG_BUILD","__SENTRY_DEBUG__","CONSOLE_LEVELS","originalConsoleMethods","logger_logger","enabled","logger","enable","disable","isEnabled","forEach","args","consoleSandbox","callback","console","wrappedFuncs","wrappedLevels","keys","level","originalConsoleMethod","SCOPE_SPAN_FIELD","_setSpanForScope","scope","span","object_addNonEnumerableProperty","defineProperty","writable","configurable","o_O","log","ScopeClass","constructor","_notifyingListeners","_scopeListeners","_eventProcessors","_breadcrumbs","_attachments","_user","_tags","_extra","_contexts","_sdkProcessingMetadata","_propagationContext","clone","newScope","_level","_session","_transactionName","_fingerprint","_requestSession","_client","_lastEventId","setClient","client","setLastEventId","lastEventId","getClient","addScopeListener","addEventProcessor","setUser","user","email","id","ip_address","username","session_updateSession","session","ipAddress","did","timestamp","abnormal_mechanism","ignoreDuration","sid","init","started","duration","release","environment","userAgent","errors","status","_notifyScopeListeners","getUser","getRequestSession","setRequestSession","requestSession","setTags","tags","setTag","key","setExtras","extras","setExtra","extra","setFingerprint","fingerprint","setLevel","setTransactionName","setContext","setSession","getSession","update","captureContext","scopeToMerge","scopeInstance","scope_Scope","getScopeData","is_isPlainObject","contexts","propagationContext","clear","addBreadcrumb","breadcrumb","maxBreadcrumbs","maxCrumbs","mergedBreadcrumb","breadcrumbs","slice","getLastBreadcrumb","clearBreadcrumbs","addAttachment","attachment","clearAttachments","attachments","eventProcessors","sdkProcessingMetadata","transactionName","setSDKProcessingMetadata","newData","setPropagationContext","getPropagationContext","captureException","exception","hint","eventId","event_id","warn","syntheticException","originalException","captureMessage","message","captureEvent","event","AsyncContextStack","isolationScope","assignedScope","assignedIsolationScope","_stack","_isolationScope","withScope","wat","maybePromiseResult","_pushScope","_popScope","res","getStackTop","getScope","getIsolationScope","getAsyncContextStack","registry","sentry","stack","withSetScope","stackStrategy_withIsolationScope","WeakMap","captureContextKeys","currentScopes_getCurrentScope","acs","asyncContext_getAsyncContextStrategy","withIsolationScope","withSetIsolationScope","getCurrentScope","some","includes"],"sourceRoot":""}